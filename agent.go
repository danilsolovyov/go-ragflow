package goragflow

import (
	"context"
	"net/http"

	"github.com/danilsolovyov/go-ragflow/options"
	"github.com/danilsolovyov/go-ragflow/parameters"
)

// TODO: autogenerated need handle refactoring.
type Agent struct {
	Avatar      interface{} `json:"avatar"`
	CanvasType  interface{} `json:"canvas_type"`
	CreateDate  string      `json:"create_date"`
	CreateTime  int64       `json:"create_time"`
	Description interface{} `json:"description"`
	DSL         DSL         `json:"dsl"`
	ID          string      `json:"id"`
	Title       string      `json:"title"`
	UpdateDate  string      `json:"update_date"`
	UpdateTime  int64       `json:"update_time"`
	UserID      any         `json:"user_id"`
	client      *Client     `json:"-"`
}

func NewAgent(id string, client *Client) *Agent {
	return &Agent{
		ID:     id,
		client: client,
	}
}

// GetMe retrieves the current agent's information from the server and updates the local agent instance.
//
// @param ctx context.Context - The context for the request.
// @return *Agent - A pointer to the updated Agent instance.
// @return error - An error if the request fails.
func (a *Agent) GetMe(ctx context.Context) (*Agent, error) {
	me, err := a.client.GetAgent(ctx, a.ID)
	if err != nil {
		return nil, err
	}

	me.client = a.client
	a = me

	return a, nil
}

// GetClient returns the Client instance associated with the Agent.
func (a *Agent) GetClient() *Client {
	return a.client
}

// SetClient sets the provided Client instance to the Agent.
// This allows the Agent to use the specified Client for its operations.
func (a *Agent) SetClient(client *Client) {
	a.client = client
}

// ListSessions retrieves a list of sessions for this agent.
//
// @param ctx context.Context - The context for the request.
// @param opts *options.ListAgentSessionsOptions - Options for filtering, pagination, and sorting sessions.
// @return []*Session - A slice of Session objects representing the retrieved sessions.
// @return error - An error if the request fails.
func (a *Agent) ListSessions(ctx context.Context, opts *options.ListAgentSessionsOptions) ([]*Session, error) {
	path := "/agents/:agent_id/sessions"
	opts = options.DefaultListAgentSessionsOptions().Merge(opts)
	opts.SetAgentID(a.ID)
	params := opts.Parameters()

	result := []*Session{}

	err := a.client.do(ctx, http.MethodGet, path, &result, params...)
	if err != nil {
		return nil, err
	}

	for i := range result {
		result[i].client = a.client
	}

	return result, nil
}

// CreateSession creates a new session for this agent.
//
// @param ctx context.Context - The context for the request.
// @param opts *options.CreateAgentSessionOptions - Options for creating the session.
// @return *Session - A pointer to the created Session object.
// @return error - An error if the request fails.
func (a *Agent) CreateSession(ctx context.Context, opts *options.CreateAgentSessionOptions) (*Session, error) {
	path := "/agents/:agent_id/sessions"

	params := []parameters.Parameter{
		parameters.NewPathParameter("agent_id", a.ID),
		parameters.NewQueryParameter("user_id", opts.UserID),
	}

	result := new(Session)

	err := a.client.do(ctx, http.MethodPost, path, result, params...)
	if err != nil {
		return nil, err
	}

	result.client = a.client

	return result, nil
}

// DeleteSessions deletes the sessions with the specified session IDs associated with the agent.
// It takes a context for cancellation and timeout control, and a slice of session IDs to delete.
// Returns an error if the deletion fails.
func (a *Agent) DeleteSessions(ctx context.Context, sessionIDs []string) error {
	return deleteAgentSessions(ctx, a.client, a.ID, sessionIDs)
}
