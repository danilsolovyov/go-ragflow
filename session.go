//
// TODO: session.go autogenerated - need handle refactoring!

package goragflow

import (
	"context"
	"net/http"

	"github.com/danilsolovyov/go-ragflow/options"
	"github.com/danilsolovyov/go-ragflow/parameters"
)

type Session struct {
	AgentID    string           `json:"agent_id"`
	CreateDate string           `json:"create_date"`
	CreateTime int64            `json:"create_time"`
	DSL        DSL              `json:"dsl"`
	Duration   int64            `json:"duration"`
	ID         string           `json:"id"`
	Messages   []SessionMessage `json:"messages"`
	Round      int64            `json:"round"`
	Source     string           `json:"source"`
	ThumbUp    int64            `json:"thumb_up"`
	Tokens     int64            `json:"tokens"`
	UpdateDate string           `json:"update_date"`
	UpdateTime int64            `json:"update_time"`
	UserID     string           `json:"user_id"`
	client     *Client          `json:"-"`
}

func (s *Session) SetClient(client *Client) {
	s.client = client
}

// Completions generates completions for the given prompt using the session's context.
func (s *Session) Completions(ctx *context.Context, opts *options.CompletionsOptions) (*Completions, error) {
	if opts == nil {
		return nil, ErrOptionsRequired
	}

	if s.AgentID != "" && opts.AgentID == "" {
		opts.SetAgentID(s.AgentID)
	}

	if s.UserID != "" && opts.UserID == "" {
		opts.SetUserID(s.UserID)
	}

	if s.ID != "" && opts.SessionID == "" {
		opts.SetSessionID(s.ID)
	}

	if opts.ChatID != "" {
		return nil, ErrNotImplementedYet
	}

	return s.agentCompletions(*ctx, opts)
}

// agentCompletions generates completions for the given prompt using the agent's model.
//
// @param ctx context.Context - The context for the request.
// @param opts *options.CompletionsOptions - The options for the completions request.
func (s *Session) agentCompletions(ctx context.Context, opts *options.CompletionsOptions) (*Completions, error) {
	path := "/agents/:agent_id/completions"
	opts = options.DefaultCompletionsOptions().Merge(opts)

	if opts.AgentID == "" {
		return nil, ErrAgentIDRequired
	}

	if s.ID != "" {
		opts.SetSessionID(s.ID)
	}

	params := opts.Parameters()

	result := new(Completions)

	err := s.client.do(ctx, http.MethodPost, path, result, params...)
	if err != nil {
		return nil, err
	}

	s.ID = result.SessionID

	return result, nil
}

func (s *Session) DeleteSession(ctx context.Context) error {
	if s.ID == "" {
		return ErrSessionIDsRequired
	}

	if s.AgentID != "" {
		return deleteAgentSessions(ctx, s.client, s.AgentID, []string{s.ID})
	}

	return nil
}

func deleteAgentSessions(ctx context.Context, client *Client, agentID string, ids []string) error {
	if agentID == "" {
		return ErrAgentIDRequired
	}

	if len(ids) == 0 {
		return ErrSessionIDsRequired
	}

	path := "/agents/:agent_id/sessions/"
	params := []parameters.Parameter{
		parameters.NewPathParameter("agent_id", agentID),
		parameters.NewBodyParameter("session_id", ids),
	}

	err := client.do(ctx, http.MethodDelete, path, nil, params...)
	if err != nil {
		return err
	}

	return nil
}
