//
// TODO: session.go autogenerated - need handle refactoring!

package goragflow

import (
	"context"
	"net/http"

	"github.com/danilsolovyov/go-ragflow/options"
	"github.com/danilsolovyov/go-ragflow/parameters"
)

type Session struct {
	AgentID    string           `json:"agent_id"`
	ChatID     string           `json:"chat_id"`
	CreateDate string           `json:"create_date"`
	CreateTime int64            `json:"create_time"`
	DSL        DSL              `json:"dsl"`
	Duration   int64            `json:"duration"`
	ID         string           `json:"id"`
	Messages   []SessionMessage `json:"messages"`
	Round      int64            `json:"round"`
	Source     string           `json:"source"`
	ThumbUp    int64            `json:"thumb_up"`
	Tokens     int64            `json:"tokens"`
	UpdateDate string           `json:"update_date"`
	UpdateTime int64            `json:"update_time"`
	UserID     string           `json:"user_id"`
	client     *Client          `json:"-"`
}

// GetClient returns the Client associated with the Session.
func (s *Session) GetClient() *Client {
	return s.client
}

// SetClient assigns the provided Client instance to the Session.
// This method allows updating or setting the client associated with the session.
func (s *Session) SetClient(client *Client) {
	s.client = client
}

// Completions generates completions for the given prompt using the session's context.
func (s *Session) Completions(ctx context.Context, opts *options.CompletionsOptions) (*Completions, error) {
	if opts == nil {
		return nil, ErrOptionsRequired
	}

	if s.UserID != "" && opts.UserID == "" {
		opts.SetUserID(s.UserID)
	}

	if s.ID != "" && opts.SessionID == "" {
		opts.SetSessionID(s.ID)
	}

	if opts.ChatID != "" {
		return nil, ErrNotImplementedYet
	}

	if s.AgentID != "" && opts.AgentID == "" {
		opts.SetAgentID(s.AgentID)
	}

	return s.agentCompletions(ctx, opts)
}

// agentCompletions generates completions for the given prompt using the agent's model.
//
// @param ctx context.Context - The context for the request.
// @param opts *options.CompletionsOptions - The options for the completions request.
func (s *Session) agentCompletions(ctx context.Context, opts *options.CompletionsOptions) (*Completions, error) {
	path := "/agents/:agent_id/completions"
	opts = options.DefaultCompletionsOptions().Merge(opts)

	if opts.AgentID == "" {
		return nil, ErrAgentIDRequired
	}

	params := opts.Parameters()

	result := new(Completions)

	err := s.client.do(ctx, http.MethodPost, path, result, params...)
	if err != nil {
		return nil, err
	}

	s.ID = result.SessionID

	return result, nil
}

// DeleteSession deletes the current session identified by the Session's ID.
// If the AgentID is set, it deletes the session for the specified agent using deleteAgentSessions.
// Returns an error if the deletion fails, or nil if successful.
func (s *Session) DeleteSession(ctx context.Context) error {
	if s.AgentID != "" {
		return deleteAgentSessions(ctx, s.client, s.AgentID, []string{s.ID})
	}

	return nil
}

// deleteAgentSessions deletes one or more sessions associated with a specific agent.
// It requires a non-empty agentID and a non-empty slice of session IDs.
// Returns an error if the agentID or session IDs are missing, or if the HTTP request fails.
//
// Parameters:
//   - ctx: Context for controlling cancellation and deadlines.
//   - client: The API client used to perform the request.
//   - agentID: The unique identifier of the agent whose sessions are to be deleted.
//   - ids: A slice of session IDs to be deleted.
//
// Returns:
//   - error: An error if the operation fails, or nil on success.
func deleteAgentSessions(ctx context.Context, client *Client, agentID string, ids []string) error {
	if agentID == "" {
		return ErrAgentIDRequired
	}

	if len(ids) == 0 {
		return ErrSessionIDsRequired
	}

	path := "/agents/:agent_id/sessions/"
	params := []parameters.Parameter{
		parameters.NewPathParameter("agent_id", agentID),
		parameters.NewBodyParameter("session_id", ids),
	}

	err := client.do(ctx, http.MethodDelete, path, nil, params...)
	if err != nil {
		return err
	}

	return nil
}
